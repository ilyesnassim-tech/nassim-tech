<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui">
    <title>Ilyes' Adventure: JS Edition</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background-color: #000; 
            overflow: hidden; 
            /* S'assurer que le jeu prend toute la place sur mobile */
            touch-action: none; 
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
</head>
<body>

<div id="game-container"></div>

<script>
// --- CONFIGURATION DU JEU ---
const config = {
    type: Phaser.AUTO,
    // La taille du jeu sera mise à l'échelle pour s'adapter à l'écran mobile
    width: 800,
    height: 600,
    parent: 'game-container',
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 1200 }, // Gravité adaptée pour Phaser
            debug: false // Mettre à true pour voir les hitboxes
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

const game = new Phaser.Game(config);

// --- CONSTANTES ---
const PLAYER_SPEED = 300;
const JUMP_FORCE = 650;
const DOUBLE_JUMP_FORCE = 550;
const MAX_LEVEL_X = 5000; // Limite du monde (5000 pixels)

let player;
let platforms;
let orbs;
let cursors;
let score = 0;
let scoreText;
let doubleJumpAvailable = true;
let isGameOver = false;
let gameOverText;

// Variables pour les contrôles tactiles (pour iPhone/mobile)
let buttonLeft, buttonRight, buttonJump;

// --- PRÉCHARGEMENT ---
function preload() {
    // Les sprites sont créés par Graphics (formes simples)
}

// --- CRÉATION DES ÉLÉMENTS DU JEU ---
function create() {
    this.cameras.main.setBackgroundColor('#181828'); // Fond Nuit
    
    // Création de textures simples pour les plateformes et l'orbe
    const platform_gfx = this.make.graphics().fillStyle(0x404040).fillRect(0, 0, 100, 20).generateTexture('platform', 100, 20);
    const orb_gfx = this.make.graphics().fillStyle(0xFFD700).fillCircle(10, 10, 10).generateTexture('orb', 20, 20);
    // Texture joueur (carré bleu néon)
    const player_gfx = this.make.graphics().fillStyle(0x00FFFF).fillRect(0, 0, 30, 50).generateTexture('player_tex', 30, 50);

    // 2. PLATEFORMES ET MONDE
    platforms = this.physics.add.staticGroup();
    orbs = this.physics.add.group();

    // --- Génération du Niveau ---
    let cursorX = 0;
    const chunkWidth = 800;
    while (cursorX < MAX_LEVEL_X) {
        if (cursorX === 0) {
            // Plateforme de départ
            platforms.create(0, 550, 'platform').setOrigin(0, 0).setDisplaySize(400, 50).refreshBody();
        } else {
            // Génération aléatoire
            const y = Phaser.Math.Between(350, 550);
            const w = Phaser.Math.Between(80, 200);
            const x = cursorX + Phaser.Math.Between(150, 300);
            const p = platforms.create(x, y, 'platform').setOrigin(0, 0).setDisplaySize(w, 20).refreshBody();
            
            // Ajouter Orbe au-dessus de la plateforme
            if (Phaser.Math.Between(0, 10) > 4) { // 60% de chance d'avoir une orbe
                 orbs.create(p.x + p.displayWidth / 2, p.y - 30, 'orb').setCircle(10).setImmovable(true).body.allowGravity = false;
            }
        }
        cursorX += chunkWidth;
    }
    
    // 3. JOUEUR (Ilyes)
    player = this.physics.add.sprite(100, 450, 'player_tex');
    player.setBounce(0.1);
    player.setCollideWorldBounds(false); 
    player.body.setSize(20, 40); 
    player.body.setOffset(5, 5);
    
    // 4. CAMÉRA
    this.cameras.main.setBounds(0, 0, MAX_LEVEL_X, 600);
    this.cameras.main.startFollow(player, true, 0.08, 0.08); // Suivi fluide

    // 5. HUD et Score
    scoreText = this.add.text(16, 16, 'Orbes: 0', { fontSize: '32px', fill: '#FFF', fontStyle: 'bold' }).setScrollFactor(0);
    
    // Texte Game Over (caché au départ)
    gameOverText = this.add.text(config.width / 2, config.height / 2, 'GAME OVER\n(Touche R ou Recharger)', {
        fontSize: '48px',
        fill: '#F00',
        backgroundColor: '#0008',
        align: 'center'
    }).setOrigin(0.5).setScrollFactor(0).setVisible(false);


    // 6. COLLISIONS
    this.physics.add.collider(player, platforms, onPlatformHit);
    this.physics.add.overlap(player, orbs, collectOrb, null, this);

    // 7. INPUTS CLAVIER
    cursors = this.input.keyboard.createCursorKeys();
    
    // R pour Recommencer
    this.input.keyboard.on('keydown-R', () => {
        if (isGameOver) {
            this.scene.restart();
        }
    });

    // 8. CONTRÔLES TACTILES (Overlay mobile)
    createMobileControls.call(this);
}

// --- LOGIQUE DE JEU ---
function collectOrb(player, orb) {
    orb.disableBody(true, true);
    score += 1;
    scoreText.setText('Orbes: ' + score);
    // Particules
    const particles = this.add.particles('orb');
    particles.createEmitter({
        speed: 100,
        lifespan: 500,
        gravityY: 50,
        quantity: 5,
        scale: { start: 0.5, end: 0 },
        x: orb.x,
        y: orb.y
    });
}

function onPlatformHit(player, platform) {
    if (player.body.touching.down) {
        doubleJumpAvailable = true; // Réactive le double saut
    }
}

function triggerGameOver(scene) {
    isGameOver = true;
    scene.physics.pause();
    player.setTint(0xff0000); // Devient rouge
    gameOverText.setVisible(true);
}

// --- CRÉATION DES BOUTONS TACTILES POUR MOBILE ---
function createMobileControls() {
    // Les boutons restent fixes à l'écran (setScrollFactor(0))
    const btnSize = 80;
    const btnAlpha = 0.6;
    const margin = 20;

    // Bouton Gauche
    buttonLeft = this.add.text(margin, config.height - btnSize - margin, ' ◀ ', {
        fontSize: '48px',
        backgroundColor: '#333',
        padding: { x: 10, y: 10 },
        fontStyle: 'bold'
    }).setScrollFactor(0).setAlpha(btnAlpha).setInteractive();

    // Bouton Droit
    buttonRight = this.add.text(margin + btnSize + 10, config.height - btnSize - margin, ' ▶ ', {
        fontSize: '48px',
        backgroundColor: '#333',
        padding: { x: 10, y: 10 },
        fontStyle: 'bold'
    }).setScrollFactor(0).setAlpha(btnAlpha).setInteractive();

    // Bouton Saut
    buttonJump = this.add.text(config.width - 150, config.height - btnSize - margin, ' SAUT ', {
        fontSize: '36px',
        backgroundColor: '#00F',
        padding: { x: 10, y: 10 },
        fontStyle: 'bold'
    }).setScrollFactor(0).setAlpha(btnAlpha).setInteractive();

    // --- Gestion des événements tactiles ---
    
    // Saut (Doit se déclencher à l'appui)
    buttonJump.on('pointerdown', () => {
        if (isGameOver) return;
        if (player.body.touching.down) {
            player.setVelocityY(-JUMP_FORCE);
        } else if (doubleJumpAvailable) {
            player.setVelocityY(-DOUBLE_JUMP_FORCE);
            doubleJumpAvailable = false;
        }
    });

    // Mouvement Gauche
    buttonLeft.isDown = false;
    buttonLeft.on('pointerdown', () => buttonLeft.isDown = true);
    buttonLeft.on('pointerup', () => buttonLeft.isDown = false);
    buttonLeft.on('pointerout', () => buttonLeft.isDown = false);

    // Mouvement Droit
    buttonRight.isDown = false;
    buttonRight.on('pointerdown', () => buttonRight.isDown = true);
    buttonRight.on('pointerup', () => buttonRight.isDown = false);
    buttonRight.on('pointerout', () => buttonRight.isDown = false);
}


// --- BOUCLE DE JEU (LOGIQUE DE MISE À JOUR) ---
function update() {
    if (isGameOver) {
        return;
    }
    
    // Logique de mouvement horizontale
    let moving = false;
    
    // Déplacement Clavier
    if (cursors.left.isDown) {
        player.setVelocityX(-PLAYER_SPEED);
        moving = true;
    } else if (cursors.right.isDown) {
        player.setVelocityX(PLAYER_SPEED);
        moving = true;
    } 
    
    // Déplacement Tactile (Priorité aux boutons s'ils sont pressés)
    if (buttonLeft.isDown) {
        player.setVelocityX(-PLAYER_SPEED);
        moving = true;
    } else if (buttonRight.isDown) {
        player.setVelocityX(PLAYER_SPEED);
        moving = true;
    } 

    if (!moving) {
        player.setVelocityX(0); // Arrêt si aucune touche/bouton n'est pressé
    }
    
    // Saut Clavier
    if (Phaser.Input.Keyboard.JustDown(cursors.space)) {
        if (player.body.touching.down) {
            player.setVelocityY(-JUMP_FORCE);
        } else if (doubleJumpAvailable) {
            player.setVelocityY(-DOUBLE_JUMP_FORCE);
            doubleJumpAvailable = false;
        }
    }

    // Gestion de la mort (chute ou fin du monde X)
    // 1. Chute dans le vide
    if (player.y > config.height + 100) {
        triggerGameOver(this);
    } 
    // 2. Fin du monde
    else if (player.x > MAX_LEVEL_X) {
        // Condition de victoire : vous avez atteint la fin ! (À implémenter)
        player.setVelocityX(0);
        player.setVelocityY(0);
        this.add.text(player.x - 200, 300, 'VICTOIRE !', { fontSize: '64px', fill: '#0F0' }).setScrollFactor(0.5);
        isGameOver = true;
    }
}
</script>
</body>
</html>
